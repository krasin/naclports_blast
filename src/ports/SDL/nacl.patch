diff --git a/Makefile.in b/Makefile.in
index e29dc6d..99321ee 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -42,7 +42,7 @@ SDLMAIN_OBJECTS = @SDLMAIN_OBJECTS@
 
 DIST = acinclude autogen.sh Borland.html Borland.zip BUGS build-scripts configure configure.in COPYING CREDITS CWprojects.sea.bin docs docs.html include INSTALL Makefile.dc Makefile.minimal Makefile.in MPWmake.sea.bin README* sdl-config.in sdl.m4 sdl.pc.in SDL.qpg.in SDL.spec SDL.spec.in src test TODO VisualCE.zip VisualC.html VisualC.zip Watcom-OS2.zip Watcom-Win32.zip symbian.zip WhatsNew Xcode.tar.gz
 
-HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
+HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_nacl.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
 
 LT_AGE      = @LT_AGE@
 LT_CURRENT  = @LT_CURRENT@
@@ -76,7 +76,7 @@ depend:
 include $(depend)
 
 $(objects)/$(TARGET): $(OBJECTS)
-	$(LIBTOOL) --mode=link $(CC) -o $@ $(OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
+	$(LIBTOOL) --mode=link $(CXX) -o $@ $(OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
 
 $(objects)/$(SDLMAIN_TARGET): $(SDLMAIN_OBJECTS)
 	$(AR) cru $@ $(SDLMAIN_OBJECTS)
diff --git a/build-scripts/config.sub b/build-scripts/config.sub
index 5ecc18b..7693a2a 100755
--- a/build-scripts/config.sub
+++ b/build-scripts/config.sub
@@ -318,6 +318,14 @@ case $basic_machine in
 	i*86 | x86_64)
 	  basic_machine=$basic_machine-pc
 	  ;;
+	nacl64*)
+	  basic_machine=x86_64-pc
+	  os=-nacl
+	  ;;
+	nacl*)
+	  basic_machine=i686-pc
+	  os=-nacl
+	  ;;
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
@@ -1309,6 +1317,9 @@ case $os in
 			;;
 		esac
 		;;
+	-nacl*)
+		os=-nacl
+		;;
 	-nto-qnx*)
 		;;
 	-nto*)
diff --git a/configure.in b/configure.in
index a7e9b18..ca1de7e 100644
--- a/configure.in
+++ b/configure.in
@@ -885,6 +885,48 @@ CheckVisibilityHidden()
     fi
 }
 
+dnl Check for Native Client stuff
+CheckNativeClient()
+{
+    AC_ARG_ENABLE(naclvideo,
+AC_HELP_STRING([--enable-naclvideo], [enable the nacl video driver [[default=yes]]]),
+                  , enable_naclvideo=yes)
+    if test x$enable_video = xyes -a x$enable_naclvideo = xyes; then
+        AC_DEFINE(SDL_VIDEO_DRIVER_NACL)
+        SOURCES="$SOURCES $srcdir/src/video/nacl/*.cc"
+        SDL_LIBS="-Wl,--start-group -lSDLmain $SDL_LIBS -lppapi -lppapi_cpp -lppapi_gles2 -Wl,--end-group -l${NACL_CPP_LIB}"
+    fi
+
+    AC_ARG_ENABLE(naclaudio,
+AC_HELP_STRING([--enable-naclaudio], [enable the nacl audio driver [[default=yes]]]),
+                  , enable_naclaudio=yes)
+    if test x$enable_audio = xyes -a x$enable_naclaudio = xyes; then
+        AC_DEFINE(SDL_AUDIO_DRIVER_NACL)
+        SOURCES="$SOURCES $srcdir/src/audio/nacl/*.cc"
+    fi
+}
+
+dnl Find Regal OpenGL library
+CheckOpenGLRegal()
+{
+    if test x$enable_video = xyes -a x$enable_video_opengl = xyes; then
+        AC_MSG_CHECKING(for OpenGL (Regal) support)
+        video_opengl=no
+        AC_TRY_COMPILE([
+         #include <GL/Regal.h>
+        ],[
+        ],[
+        video_opengl=yes
+        ])
+        AC_MSG_RESULT($video_opengl)
+        if test x$video_opengl = xyes; then
+            AC_DEFINE(SDL_VIDEO_OPENGL)
+            AC_DEFINE(SDL_VIDEO_OPENGL_REGAL)
+            SDL_LIBS="$SDL_LIBS -lRegal -l${NACL_CPP_LIB}"
+        fi
+    fi
+}
+
 
 dnl Do the iPod thing
 CheckIPod()
@@ -2284,6 +2326,22 @@ case "$host" in
             have_timers=yes
         fi
         ;;
+    *-nacl)
+        ARCH=nacl
+        CheckNativeClient
+        CheckOpenGLRegal
+        CheckDummyAudio
+        CheckDummyVideo
+        CheckInputEvents
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_UNIX)
+            SOURCES="$SOURCES $srcdir/src/timer/unix/*.c"
+            have_timers=yes
+        fi
+        CheckPTHREAD
+        SDLMAIN_SOURCES="$srcdir/src/main/nacl/*.cc"
+        ;;
     *-*-linux*|*-*-uclinux*|*-*-gnu*|*-*-k*bsd*-gnu|*-*-bsdi*|*-*-freebsd*|*-*-dragonfly*|*-*-netbsd*|*-*-openbsd*|*-*-sysv5*|*-*-solaris*|*-*-hpux*|*-*-irix*|*-*-aix*|*-*-osf*)
         case "$host" in
             *-*-linux*)         ARCH=linux ;;
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index 58593ca..150097d 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -174,6 +174,7 @@
 #undef SDL_AUDIO_DRIVER_ESD_DYNAMIC
 #undef SDL_AUDIO_DRIVER_MINT
 #undef SDL_AUDIO_DRIVER_MMEAUDIO
+#undef SDL_AUDIO_DRIVER_NACL
 #undef SDL_AUDIO_DRIVER_NAS
 #undef SDL_AUDIO_DRIVER_NAS_DYNAMIC
 #undef SDL_AUDIO_DRIVER_OSS
@@ -265,6 +266,7 @@
 #undef SDL_VIDEO_DRIVER_GEM
 #undef SDL_VIDEO_DRIVER_GGI
 #undef SDL_VIDEO_DRIVER_IPOD
+#undef SDL_VIDEO_DRIVER_NACL
 #undef SDL_VIDEO_DRIVER_NANOX
 #undef SDL_VIDEO_DRIVER_OS2FS
 #undef SDL_VIDEO_DRIVER_PHOTON
@@ -295,6 +297,7 @@
 /* Enable OpenGL support */
 #undef SDL_VIDEO_OPENGL
 #undef SDL_VIDEO_OPENGL_GLX
+#undef SDL_VIDEO_OPENGL_REGAL
 #undef SDL_VIDEO_OPENGL_WGL
 #undef SDL_VIDEO_OPENGL_OSMESA
 #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC
diff --git a/include/SDL_main.h b/include/SDL_main.h
index b7f6b2c..cdde128 100644
--- a/include/SDL_main.h
+++ b/include/SDL_main.h
@@ -32,7 +32,7 @@
 #if defined(__WIN32__) || \
     (defined(__MWERKS__) && !defined(__BEOS__)) || \
     defined(__MACOS__) || defined(__MACOSX__) || \
-    defined(__SYMBIAN32__) || defined(QWS)
+    defined(__SYMBIAN32__) || defined(QWS) || defined(__native_client__)
 
 #ifdef __cplusplus
 #define C_LINKAGE	"C"
diff --git a/include/SDL_nacl.h b/include/SDL_nacl.h
new file mode 100644
index 0000000..11670fb
--- /dev/null
+++ b/include/SDL_nacl.h
@@ -0,0 +1,24 @@
+#ifndef _SDL_nacl_h
+#define _SDL_nacl_h
+
+#include "begin_code.h"
+#include <ppapi/cpp/input_event.h>
+
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <ppapi/c/ppp_instance.h>
+void SDL_NACL_SetInstance(PP_Instance instance, int width, int height);
+void SDL_NACL_PushEvent(const pp::InputEvent& ppevent);
+void SDL_NACL_SetHasFocus(bool has_focus);
+void SDL_NACL_SetPageVisible(bool is_visible);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include "close_code.h"
+
+#endif /* _SDL_nacl_h */
diff --git a/include/SDL_opengl.h b/include/SDL_opengl.h
index c479a3a..a0f4962 100644
--- a/include/SDL_opengl.h
+++ b/include/SDL_opengl.h
@@ -33,7 +33,7 @@
 #endif
 #include <windows.h>
 #endif
-#ifndef NO_SDL_GLEXT
+#if !defined(NO_SDL_GLEXT) && !defined(__native_client__)
 #define __glext_h_  /* Don't let gl.h include glext.h */
 #endif
 #if defined(__MACOSX__)
@@ -42,6 +42,10 @@
 #elif defined(__MACOS__)
 #include <gl.h>		/* Header File For The OpenGL Library */
 #include <glu.h>	/* Header File For The GLU Library */
+#elif defined(__native_client__)
+#include <GL/Regal.h>
+#define APIENTRY
+#define APIENTRYP APIENTRY *
 #else
 #include <GL/gl.h>	/* Header File For The OpenGL Library */
 #include <GL/glu.h>	/* Header File For The GLU Library */
diff --git a/include/SDL_platform.h b/include/SDL_platform.h
index 11d8673..dd99403 100644
--- a/include/SDL_platform.h
+++ b/include/SDL_platform.h
@@ -63,10 +63,14 @@
 #undef __IRIX__
 #define __IRIX__	1
 #endif
-#if defined(linux) || defined(__linux) || defined(__linux__)
+#if defined(linux) || defined(__linux) || defined(__linux__) && !defined(__native_client__)
 #undef __LINUX__
 #define __LINUX__	1
 #endif
+#if defined(__native_client__)
+#undef __NACL__
+#define __NACL__ 1
+#endif
 #if defined(__APPLE__)
 #undef __MACOSX__
 #define __MACOSX__	1
diff --git a/src/SDL_fatal.c b/src/SDL_fatal.c
index 15c0be7..82ceeef 100644
--- a/src/SDL_fatal.c
+++ b/src/SDL_fatal.c
@@ -39,7 +39,11 @@ static void SDL_Parachute(int sig)
 {
 	signal(sig, SIG_DFL);
 	SDL_Quit();
+#ifdef __native_client__
+	exit(sig);
+#else
 	raise(sig);
+#endif
 }
 
 static int SDL_fatal_signals[] = {
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index bdeacdc..ac43356 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -36,6 +36,9 @@
 
 /* Available audio drivers */
 static AudioBootStrap *bootstrap[] = {
+#if SDL_AUDIO_DRIVER_NACL
+	&NACLAUD_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_BSD
 	&BSD_AUDIO_bootstrap,
 #endif
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index 50cf179..7b9a0a7 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -156,6 +156,9 @@ extern AudioBootStrap MINTAUDIO_STFA_bootstrap;
 extern AudioBootStrap MINTAUDIO_XBIOS_bootstrap;
 extern AudioBootStrap MINTAUDIO_DMA8_bootstrap;
 #endif
+#if SDL_AUDIO_DRIVER_NACL
+extern AudioBootStrap NACLAUD_bootstrap;
+#endif
 #if SDL_AUDIO_DRIVER_DISK
 extern AudioBootStrap DISKAUD_bootstrap;
 #endif
diff --git a/src/audio/nacl/SDL_naclaudio.cc b/src/audio/nacl/SDL_naclaudio.cc
new file mode 100644
index 0000000..83ede7c
--- /dev/null
+++ b/src/audio/nacl/SDL_naclaudio.cc
@@ -0,0 +1,137 @@
+
+#include "SDL_config.h"
+#include "SDL_naclaudio.h"
+
+#include <assert.h>
+#include <ppapi/cpp/instance.h>
+
+extern pp::Instance* gNaclPPInstance;
+
+extern "C" {
+
+#include "SDL_rwops.h"
+#include "SDL_timer.h"
+#include "SDL_audio.h"
+#include "SDL_mutex.h"
+#include "../SDL_audiomem.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_audiodev_c.h"
+
+  /* The tag name used by NACL audio */
+#define NACLAUD_DRIVER_NAME         "nacl"
+
+const uint32_t kSampleFrameCount = 4096u;
+
+/* Audio driver functions */
+static int NACLAUD_OpenAudio(_THIS, SDL_AudioSpec *spec);
+static void NACLAUD_CloseAudio(_THIS);
+
+static void AudioCallback(void* samples, uint32_t buffer_size, void* data);
+
+
+/* Audio driver bootstrap functions */
+static int NACLAUD_Available(void) {
+  return gNaclPPInstance != 0;
+}
+
+static void NACLAUD_DeleteDevice(SDL_AudioDevice *device) {
+  // We should stop playback here, but it can only be done on the main thread :(
+}
+
+static SDL_AudioDevice *NACLAUD_CreateDevice(int devindex) {
+  SDL_AudioDevice *_this;
+
+  /* Initialize all variables that we clean on shutdown */
+  _this = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
+  if ( _this ) {
+    SDL_memset(_this, 0, (sizeof *_this));
+    _this->hidden = (struct SDL_PrivateAudioData *)
+        SDL_malloc((sizeof *_this->hidden));
+  }
+  if ( (_this == NULL) || (_this->hidden == NULL) ) {
+    SDL_OutOfMemory();
+    if ( _this ) {
+      SDL_free(_this);
+    }
+    return(0);
+  }
+  SDL_memset(_this->hidden, 0, (sizeof *_this->hidden));
+
+  _this->hidden->mutex = SDL_CreateMutex();
+
+  _this->hidden->opened = false;
+
+  // TODO: Move audio device creation to NACLAUD_OpenAudio.
+  _this->hidden->sample_frame_count =
+      pp::AudioConfig::RecommendSampleFrameCount(
+#ifdef PPB_AUDIO_CONFIG_INTERFACE_1_1
+          gNaclPPInstance,
+#endif
+          PP_AUDIOSAMPLERATE_44100,
+          kSampleFrameCount);
+  _this->hidden->audio = pp::Audio(
+      gNaclPPInstance,
+      pp::AudioConfig(gNaclPPInstance,
+          PP_AUDIOSAMPLERATE_44100,
+          _this->hidden->sample_frame_count),
+      AudioCallback, _this);
+
+  // Start audio playback while we are still on the main thread.
+  _this->hidden->audio.StartPlayback();
+
+  /* Set the function pointers */
+  _this->OpenAudio = NACLAUD_OpenAudio;
+  _this->CloseAudio = NACLAUD_CloseAudio;
+
+  _this->free = NACLAUD_DeleteDevice;
+
+  return _this;
+}
+
+AudioBootStrap NACLAUD_bootstrap = {
+  NACLAUD_DRIVER_NAME, "SDL nacl audio driver",
+  NACLAUD_Available, NACLAUD_CreateDevice
+};
+
+
+static void NACLAUD_CloseAudio(_THIS) {
+  SDL_LockMutex(_this->hidden->mutex);
+  _this->hidden->opened = 0;
+  SDL_UnlockMutex(_this->hidden->mutex);
+}
+
+
+static void AudioCallback(void* samples, uint32_t buffer_size, void* data) {
+  SDL_AudioDevice* _this = reinterpret_cast<SDL_AudioDevice*>(data);
+
+  SDL_LockMutex(_this->hidden->mutex);
+  if (_this->hidden->opened) {
+    SDL_memset(samples, _this->spec.silence, buffer_size);
+    SDL_LockMutex(_this->mixer_lock);
+    (*_this->spec.callback)(_this->spec.userdata,
+        (Uint8*)samples, buffer_size);
+    SDL_UnlockMutex(_this->mixer_lock);
+  } else {
+    SDL_memset(samples, 0, buffer_size);
+  }
+  SDL_UnlockMutex(_this->hidden->mutex);
+
+  return;
+}
+
+
+static int NACLAUD_OpenAudio(_THIS, SDL_AudioSpec *spec) {
+  // We don't care what the user wants.
+  spec->freq = 44100;
+  spec->format = AUDIO_S16LSB;
+  spec->channels = 2;
+  spec->samples = _this->hidden->sample_frame_count;
+
+  SDL_LockMutex(_this->hidden->mutex);
+  _this->hidden->opened = 1;
+  SDL_UnlockMutex(_this->hidden->mutex);
+
+  // Do not create an audio thread.
+  return 1;
+}
+} // extern "C"
diff --git a/src/audio/nacl/SDL_naclaudio.h b/src/audio/nacl/SDL_naclaudio.h
new file mode 100644
index 0000000..e095c34
--- /dev/null
+++ b/src/audio/nacl/SDL_naclaudio.h
@@ -0,0 +1,30 @@
+#include "SDL_config.h"
+
+#ifndef _SDL_naclaudio_h
+#define _SDL_naclaudio_h
+
+extern "C" {
+#include "SDL_audio.h"
+#include "../SDL_sysaudio.h"
+#include "SDL_mutex.h"
+}
+
+#include <ppapi/cpp/audio.h>
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_AudioDevice *_this
+
+struct SDL_PrivateAudioData {
+
+  SDL_mutex* mutex;
+  // This flag is use to determine when the audio is opened and we can start
+  // serving audio data instead of silence. This is needed because current
+  // Pepper2 can only be used from the main thread; Therefore, we start the
+  // audio thread very early.
+  bool opened;
+
+  int sample_frame_count;
+  pp::Audio audio;
+};
+
+#endif /* _SDL_naclaudio_h */
diff --git a/src/cpuinfo/SDL_cpuinfo.c b/src/cpuinfo/SDL_cpuinfo.c
index 5c2d81f..7a757a3 100644
--- a/src/cpuinfo/SDL_cpuinfo.c
+++ b/src/cpuinfo/SDL_cpuinfo.c
@@ -53,6 +53,8 @@ static void illegal_instruction(int sig)
 }
 #endif /* HAVE_SETJMP */
 
+
+#if SDL_ASSEMBLY_ROUTINES
 static __inline__ int CPU_haveCPUID(void)
 {
 	int has_CPUID = 0;
@@ -280,6 +282,15 @@ done:
 	return features;
 }
 
+#else // SDL_ASSEMBLY_ROUTINES
+
+static __inline__ int CPU_haveCPUID(void) { return 0; }
+static __inline__ int CPU_getCPUIDFeaturesExt(void) { return 0; }
+static __inline__ int CPU_getCPUIDFeatures(void) { return 0; }
+
+#endif // SDL_ASSEMBLY_ROUTINES
+
+
 static __inline__ int CPU_haveRDTSC(void)
 {
 	if ( CPU_haveCPUID() ) {
diff --git a/src/main/nacl/pepper_instance.cc b/src/main/nacl/pepper_instance.cc
new file mode 100644
index 0000000..7356235
--- /dev/null
+++ b/src/main/nacl/pepper_instance.cc
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2011 The Native Client Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include <assert.h>
+#include <vector>
+#include <unistd.h>
+#include <fcntl.h>
+#include <SDL.h>
+#include <SDL_nacl.h>
+#include <SDL_video.h>
+#include <SDL_main.h>
+#include <sys/mount.h>
+
+#include <ppapi/cpp/module.h>
+#include "pepper_instance.h"
+#include "nacl_io/nacl_io.h"
+
+SDLPepperInstance::SDLPepperInstance(PP_Instance instance)
+  : pp::Instance(instance),
+    width_(0),
+    height_(0) {
+  RequestInputEvents(PP_INPUTEVENT_CLASS_MOUSE);
+  RequestFilteringInputEvents(PP_INPUTEVENT_CLASS_KEYBOARD);
+}
+
+bool SDLPepperInstance::Init(uint32_t argc, const char* argn[], const char* argv[]) {
+  nacl_io_init_ppapi(pp_instance(),
+                     pp::Module::Get()->get_browser_interface());
+
+  for (int i = 0; i < argc; i++) {
+    if (!strcmp(argn[i], "ps_stdout")) {
+      int fd1 = open(argv[i], O_WRONLY);
+      dup2(fd1, 1);
+    }
+    if (!strcmp(argn[i], "ps_stderr")) {
+      int fd2 = open(argv[i], O_WRONLY);
+      dup2(fd2, 2);
+    }
+  }
+
+  return true;
+}
+
+/*
+ * Entry point for the main SDL thread.  The job of this thread is to
+ * run SDL_main, which in most cases is the application's main() function
+ * re-defined by the pre-processor in SDL_main.h.
+ */
+static void* sdl_thread_start(void* arg)
+{
+  // Create an http mount by default
+  fprintf(stderr, "SDL: creating http mount\n");
+  umount("/");
+  mount("", "/", "httpfs", 0, "");
+
+  fprintf(stderr, "SDL: calling SDL_main\n");
+  char* argv[2];
+  argv[0] = (char*)"SDL applicaiton";
+  argv[1] = NULL;
+  int rtn = SDL_main(1, argv);
+  fprintf(stderr, "SDL: SDL_main returned: %d\n", rtn);
+  exit(rtn);
+  return NULL;
+}
+
+void SDLPepperInstance::DidChangeView(const pp::Rect& position, const pp::Rect& clip) {
+  if (width_ && height_)
+    return;
+
+  if (position.size().width() == width_ &&
+      position.size().height() == height_)
+    return;  // Size didn't change, no need to update anything.
+
+  width_ = position.size().width();
+  height_ = position.size().height();
+
+  SDL_NACL_SetInstance(pp_instance(), width_, height_);
+  pthread_create(&sdl_thread_, NULL, sdl_thread_start, NULL);
+}
+
+bool SDLPepperInstance::HandleInputEvent(const pp::InputEvent& event) {
+  SDL_NACL_PushEvent(event);
+  return true;
+}
+
diff --git a/src/main/nacl/pepper_instance.h b/src/main/nacl/pepper_instance.h
new file mode 100644
index 0000000..b91e637
--- /dev/null
+++ b/src/main/nacl/pepper_instance.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2013 The Native Client Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SDL_PEPPER_INSTANCE_H_
+#define SDL_PEPPER_INSTANCE_H_
+
+#include <pthread.h>
+#include <ppapi/cpp/input_event.h>
+#include <ppapi/cpp/instance.h>
+#include <ppapi/cpp/rect.h>
+
+class SDLPepperInstance : public pp::Instance {
+ public:
+  explicit SDLPepperInstance(PP_Instance instance);
+
+  virtual ~SDLPepperInstance() {}
+
+  virtual bool Init(uint32_t argc, const char* argn[], const char* argv[]);
+
+  void DidChangeView(const pp::Rect& position, const pp::Rect& clip);
+
+  bool HandleInputEvent(const pp::InputEvent& event);
+
+ private:
+  pthread_t sdl_thread_;
+  int width_;
+  int height_;
+};
+
+#endif  // SDL_PEPPER_INSTANCE_H_
diff --git a/src/main/nacl/pepper_module.cc b/src/main/nacl/pepper_module.cc
new file mode 100644
index 0000000..1ab4278
--- /dev/null
+++ b/src/main/nacl/pepper_module.cc
@@ -0,0 +1,31 @@
+// Copyright 2013 The Native Client SDK Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can
+// be found in the LICENSE file.
+
+#include <ppapi/cpp/module.h>
+#include <stdio.h>
+#include "pepper_instance.h"
+
+// The Module class.  The browser calls the CreateInstance() method to create
+// an instance of you NaCl module on the web page.  The browser creates a new
+// instance for each <embed> tag with type="application/x-ppapi-nacl-srpc".
+class SDLPepperModule : public pp::Module {
+public:
+  SDLPepperModule() : pp::Module() {}
+  virtual ~SDLPepperModule() {}
+
+  virtual pp::Instance* CreateInstance(PP_Instance instance) {
+    return new SDLPepperInstance(instance);
+  }
+};
+
+// Factory function called by the browser when the module is first loaded.
+// The browser keeps a singleton of this module.  It calls the
+// CreateInstance() method on the object you return to make instances.  There
+// is one instance per <embed> tag on the page.  This is the main binding
+// point for your NaCl module with the browser.
+namespace pp {
+  Module* CreateModule() {
+    return new SDLPepperModule();
+  }
+}  // namespace pp
diff --git a/src/thread/pthread/SDL_systhread.c b/src/thread/pthread/SDL_systhread.c
index 479bf34..a3b9119 100644
--- a/src/thread/pthread/SDL_systhread.c
+++ b/src/thread/pthread/SDL_systhread.c
@@ -81,12 +81,15 @@ void SDL_SYS_SetupThread(void)
 	int i;
 	sigset_t mask;
 
+	// NativeClient does not yet support signals.
+#ifndef __NACL__
 	/* Mask asynchronous signals for this thread */
 	sigemptyset(&mask);
 	for ( i=0; sig_list[i]; ++i ) {
 		sigaddset(&mask, sig_list[i]);
 	}
 	pthread_sigmask(SIG_BLOCK, &mask, 0);
+#endif
 
 #ifdef PTHREAD_CANCEL_ASYNCHRONOUS
 	/* Allow ourselves to be asynchronously cancelled */
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index 1c72e09..9fc1a85 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -317,6 +317,9 @@ typedef struct VideoBootStrap {
 	SDL_VideoDevice *(*create)(int devindex);
 } VideoBootStrap;
 
+#if SDL_VIDEO_DRIVER_NACL
+extern VideoBootStrap NACL_bootstrap;
+#endif
 #if SDL_VIDEO_DRIVER_QUARTZ
 extern VideoBootStrap QZ_bootstrap;
 #endif
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index e84ef35..f8a5090 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -33,6 +33,9 @@
 
 /* Available video drivers */
 static VideoBootStrap *bootstrap[] = {
+#if SDL_VIDEO_DRIVER_NACL
+	&NACL_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_QUARTZ
 	&QZ_bootstrap,
 #endif
@@ -764,6 +767,8 @@ SDL_Surface * SDL_SetVideoMode (int width, int height, int bpp, Uint32 flags)
 #define __SDL_NOGETPROCADDR__
 #elif defined(__MINT__)
 #define __SDL_NOGETPROCADDR__
+#elif defined(__native_client__)
+#define __SDL_NOGETPROCADDR__
 #endif
 #ifdef __SDL_NOGETPROCADDR__
     #define SDL_PROC(ret,func,params) video->func=func;
diff --git a/src/video/nacl/SDL_naclevents.cc b/src/video/nacl/SDL_naclevents.cc
new file mode 100644
index 0000000..98267e4
--- /dev/null
+++ b/src/video/nacl/SDL_naclevents.cc
@@ -0,0 +1,307 @@
+#include "SDL_config.h"
+
+#include "SDL_nacl.h"
+
+extern "C" {
+#include "SDL.h"
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+}
+
+#include "SDL_naclevents_c.h"
+#include "eventqueue.h"
+#include <ppapi/cpp/input_event.h>
+#include <ppapi/cpp/point.h>
+#include <ppapi/cpp/var.h>
+
+#include <math.h>
+
+static EventQueue event_queue;
+
+static Uint8 translateButton(int32_t button) {
+  switch (button) {
+    case PP_INPUTEVENT_MOUSEBUTTON_LEFT:
+      return SDL_BUTTON_LEFT;
+    case PP_INPUTEVENT_MOUSEBUTTON_MIDDLE:
+      return SDL_BUTTON_MIDDLE;
+    case PP_INPUTEVENT_MOUSEBUTTON_RIGHT:
+      return SDL_BUTTON_RIGHT;
+    case PP_INPUTEVENT_MOUSEBUTTON_NONE:
+    default:
+      return 0;
+  }
+}
+
+// Translate ASCII code to browser keycode
+static uint8_t translateAscii(uint8_t ascii) {
+  if ('A' <= ascii && ascii <= 'Z') {
+    return ascii;
+  } else if ('a' <= ascii && ascii <= 'z') {
+    return toupper(ascii);
+  } else if ('0' <= ascii && ascii <= '9') {
+    return ascii;
+  } else if (' ' == ascii || '\r' == ascii || '\t' == ascii ||
+             '\x1b' == ascii || '\b' == ascii) {
+    return ascii;
+  } else {
+    switch (ascii) {
+      case '!': return '1';
+      case '@': return '2';
+      case '#': return '3';
+      case '$': return '4';
+      case '%': return '5';
+      case '^': return '6';
+      case '&': return '7';
+      case '*': return '8';
+      case '(': return '9';
+      case ')': return '0';
+      case ';': case ':': return 186;
+      case '=': case '+': return 187;
+      case ',': case '<': return 188;
+      case '-': case '_': return 189;
+      case '.': case '>': return 190;
+      case '/': case '?': return 191;
+      case '`': case '~': return 192;
+      case '[': case '{': return 219;
+      case '\\': case '|': return 220;
+      case ']': case '}': return 221;
+      case '\'': case '"': return 222;
+      default:
+        break;
+    }
+  }
+  return 0;
+}
+
+// Translate browser keycode to SDLKey
+static SDLKey translateKey(uint32_t code) {
+  if (code >= 'A' && code <= 'Z')
+    return (SDLKey)(code - 'A' + SDLK_a);
+  if (code >= SDLK_0 && code <= SDLK_9)
+    return (SDLKey)code;
+  const uint32_t f1_code = 112;
+  if (code >= f1_code && code < f1_code + 12)
+    return (SDLKey)(code - f1_code + SDLK_F1);
+  const uint32_t kp0_code = 96;
+  if (code >= kp0_code && code < kp0_code + 10)
+    return (SDLKey)(code - kp0_code + SDLK_KP0);
+  switch (code) {
+    case SDLK_BACKSPACE:
+      return SDLK_BACKSPACE;
+    case SDLK_TAB:
+      return SDLK_TAB;
+    case SDLK_RETURN:
+      return SDLK_RETURN;
+    case SDLK_PAUSE:
+      return SDLK_PAUSE;
+    case SDLK_ESCAPE:
+      return SDLK_ESCAPE;
+    case 16:
+      return SDLK_LSHIFT;
+    case 17:
+      return SDLK_LCTRL;
+    case 18:
+      return SDLK_LALT;
+    case 32:
+      return SDLK_SPACE;
+    case 37:
+      return SDLK_LEFT;
+    case 38:
+      return SDLK_UP;
+    case 39:
+      return SDLK_RIGHT;
+    case 40:
+      return SDLK_DOWN;
+    case 106:
+      return SDLK_KP_MULTIPLY;
+    case 107:
+      return SDLK_KP_PLUS;
+    case 109:
+      return SDLK_KP_MINUS;
+    case 110:
+      return SDLK_KP_PERIOD;
+    case 111:
+      return SDLK_KP_DIVIDE;
+    case 45:
+      return SDLK_INSERT;
+    case 46:
+      return SDLK_DELETE;
+    case 36:
+      return SDLK_HOME;
+    case 35:
+      return SDLK_END;
+    case 33:
+      return SDLK_PAGEUP;
+    case 34:
+      return SDLK_PAGEDOWN;
+    case 189:
+      return SDLK_MINUS;
+    case 187:
+      return SDLK_EQUALS;
+    case 219:
+      return SDLK_LEFTBRACKET;
+    case 221:
+      return SDLK_RIGHTBRACKET;
+    case 186:
+      return SDLK_SEMICOLON;
+    case 222:
+      return SDLK_QUOTE;
+    case 220:
+      return SDLK_BACKSLASH;
+    case 188:
+      return SDLK_COMMA;
+    case 190:
+      return SDLK_PERIOD;
+    case 191:
+      return SDLK_SLASH;
+    case 192:
+      return SDLK_BACKQUOTE;
+    default:
+      return SDLK_UNKNOWN;
+  }
+}
+
+static SDL_Event *copyEvent(SDL_Event *event) {
+  SDL_Event *event_copy = (SDL_Event*)malloc(sizeof(SDL_Event));
+  *event_copy = *event;
+  return event_copy;
+}
+
+void SDL_NACL_PushEvent(const pp::InputEvent& ppevent) {
+  static Uint8 last_scancode = 0;
+  SDL_keysym keysym;
+  static double wheel_clicks_x;
+  static double wheel_clicks_y;
+  SDL_Event event;
+  PP_InputEvent_Type type = ppevent.GetType();
+
+  pp::InputEvent *input_event = const_cast<pp::InputEvent*>(&ppevent);
+
+  if (type == PP_INPUTEVENT_TYPE_MOUSEDOWN ||
+      type == PP_INPUTEVENT_TYPE_MOUSEUP) {
+    pp::MouseInputEvent *mouse_event =
+      reinterpret_cast<pp::MouseInputEvent*>(input_event);
+    event.type = (type == PP_INPUTEVENT_TYPE_MOUSEUP) ? SDL_MOUSEBUTTONUP : SDL_MOUSEBUTTONDOWN;
+    event.button.button = translateButton(mouse_event->GetButton());
+    event.button.x = mouse_event->GetPosition().x();
+    event.button.y = mouse_event->GetPosition().y();
+    event_queue.PushEvent(copyEvent(&event));
+  } else if (type == PP_INPUTEVENT_TYPE_WHEEL) {
+    pp::WheelInputEvent *wheel_event =
+      reinterpret_cast<pp::WheelInputEvent*>(input_event);
+    wheel_clicks_x += wheel_event->GetTicks().x();
+    wheel_clicks_y += wheel_event->GetTicks().y();
+    int sdl_wheel_clicks_x = trunc(wheel_clicks_x);
+    int sdl_wheel_clicks_y = trunc(wheel_clicks_y);
+    event.button.x = event.button.y = 0;
+    event.button.button = (sdl_wheel_clicks_x > 0) ? SDL_BUTTON_X1 : SDL_BUTTON_X2;
+    for (int i = 0; i < abs(sdl_wheel_clicks_x); i++) {
+      event.type = SDL_MOUSEBUTTONDOWN;
+      event_queue.PushEvent(copyEvent(&event));
+      event.type = SDL_MOUSEBUTTONUP;
+      event_queue.PushEvent(copyEvent(&event));
+    }
+    event.button.button = (sdl_wheel_clicks_y > 0) ? SDL_BUTTON_WHEELUP : SDL_BUTTON_WHEELDOWN;
+    for (int i = 0; i < abs(sdl_wheel_clicks_y); i++) {
+      event.type = SDL_MOUSEBUTTONDOWN;
+      event_queue.PushEvent(copyEvent(&event));
+      event.type = SDL_MOUSEBUTTONUP;
+      event_queue.PushEvent(copyEvent(&event));
+    }
+    wheel_clicks_x -= sdl_wheel_clicks_x;
+    wheel_clicks_y -= sdl_wheel_clicks_y;
+  } else if (type == PP_INPUTEVENT_TYPE_MOUSEMOVE) {
+    pp::MouseInputEvent *mouse_event =
+      reinterpret_cast<pp::MouseInputEvent*>(input_event);
+    event.type = SDL_MOUSEMOTION;
+    event.motion.x = mouse_event->GetPosition().x();
+    event.motion.y = mouse_event->GetPosition().y();
+    event_queue.PushEvent(copyEvent(&event));
+  } else if (type == PP_INPUTEVENT_TYPE_KEYDOWN ||
+             type == PP_INPUTEVENT_TYPE_KEYUP ||
+             type == PP_INPUTEVENT_TYPE_CHAR) {
+    // PPAPI sends us separate events for KEYDOWN and CHAR; the first one
+    // contains only the keycode, the second one - only the unicode text.
+    // SDL wants both in SDL_PRESSED event :(
+    // For now, ignore the keydown event for printable ascii (32-126) as we
+    // know we'll get a char event and can set sym directly. For everything
+    // else, risk sending an extra SDL_PRESSED with unicode text and zero
+    // keycode for scancode / sym.
+    // It seems that SDL 1.3 is better in this regard.
+    pp::KeyboardInputEvent *keyboard_event =
+      reinterpret_cast<pp::KeyboardInputEvent*>(input_event);
+    keysym.scancode = keyboard_event->GetKeyCode();
+    keysym.unicode = keyboard_event->GetCharacterText().AsString()[0];
+    keysym.sym = translateKey(keysym.scancode);
+    if (type == PP_INPUTEVENT_TYPE_KEYDOWN) {
+      event.type = SDL_KEYDOWN;
+      last_scancode = keysym.scancode;
+      if (keysym.sym >= ' ' &&  keysym.sym <= 126) {
+        return;
+      }
+    } else if (type == PP_INPUTEVENT_TYPE_CHAR) {
+      event.type = SDL_KEYDOWN;
+      if (keysym.sym >= ' ' &&  keysym.sym <= 126) {
+        keysym.scancode = translateAscii(keysym.unicode);
+        keysym.sym = translateKey(keysym.scancode);
+      } else if (last_scancode) {
+        keysym.scancode = last_scancode;
+        keysym.sym = translateKey(keysym.scancode);
+      }
+    } else {  // event->type == PP_INPUTEVENT_TYPE_KEYUP
+      event.type = SDL_KEYUP;
+      last_scancode = 0;
+    }
+    keysym.mod = KMOD_NONE;
+    event.key.keysym = keysym;
+    event_queue.PushEvent(copyEvent(&event));
+  } else if (type == PP_INPUTEVENT_TYPE_MOUSEENTER ||
+             type == PP_INPUTEVENT_TYPE_MOUSELEAVE) {
+    event.type = SDL_ACTIVEEVENT;
+    event.active.gain = (type == PP_INPUTEVENT_TYPE_MOUSEENTER) ? 1 : 0;
+    event.active.state = SDL_APPMOUSEFOCUS;
+    event_queue.PushEvent(copyEvent(&event));
+  }
+}
+
+void SDL_NACL_SetHasFocus(bool has_focus) {
+  SDL_Event event;
+  event.type = SDL_ACTIVEEVENT;
+  event.active.gain = has_focus ? 1 : 0;
+  event.active.state = SDL_APPINPUTFOCUS;
+  event_queue.PushEvent(copyEvent(&event));
+}
+
+void SDL_NACL_SetPageVisible(bool is_visible) {
+  SDL_Event event;
+  event.type = SDL_ACTIVEEVENT;
+  event.active.gain = is_visible ? 1 : 0;
+  event.active.state = SDL_APPACTIVE;
+  event_queue.PushEvent(copyEvent(&event));
+}
+
+void NACL_PumpEvents(_THIS) {
+  SDL_Event* event;
+  while (event = event_queue.PopEvent()) {
+    if (event->type == SDL_MOUSEBUTTONDOWN) {
+      SDL_PrivateMouseButton(SDL_PRESSED, event->button.button,
+                             event->button.x, event->button.y);
+    } else if (event->type == SDL_MOUSEBUTTONUP) {
+      SDL_PrivateMouseButton(SDL_RELEASED, event->button.button,
+                             event->button.x, event->button.y);
+    } else if (event->type == SDL_MOUSEMOTION) {
+      SDL_PrivateMouseMotion(0, 0, event->motion.x, event->motion.y);
+    } else if (event->type == SDL_KEYDOWN) {
+      SDL_PrivateKeyboard(SDL_PRESSED, &event->key.keysym);
+    } else if (event->type == SDL_KEYUP) {
+      SDL_PrivateKeyboard(SDL_RELEASED, &event->key.keysym);
+    } else if (event->type == SDL_ACTIVEEVENT) {
+      SDL_PrivateAppActive(event->active.gain, event->active.state);
+    }
+    free(event);
+  }
+}
+
+void NACL_InitOSKeymap(_THIS) {
+  /* do nothing. */
+}
diff --git a/src/video/nacl/SDL_naclevents_c.h b/src/video/nacl/SDL_naclevents_c.h
new file mode 100644
index 0000000..71ae309
--- /dev/null
+++ b/src/video/nacl/SDL_naclevents_c.h
@@ -0,0 +1,7 @@
+#include "SDL_config.h"
+
+#include "SDL_naclvideo.h"
+#include "SDL_nacl.h"
+
+extern void NACL_InitOSKeymap(_THIS);
+extern void NACL_PumpEvents(_THIS);
diff --git a/src/video/nacl/SDL_naclvideo.cc b/src/video/nacl/SDL_naclvideo.cc
new file mode 100644
index 0000000..f44377d
--- /dev/null
+++ b/src/video/nacl/SDL_naclvideo.cc
@@ -0,0 +1,401 @@
+#include "SDL_config.h"
+
+#include <assert.h>
+
+#include "SDL_naclvideo.h"
+#include "SDL_naclevents_c.h"
+
+#include <ppapi/cpp/instance.h>
+#include <ppapi/cpp/completion_callback.h>
+#include <ppapi/cpp/image_data.h>
+#include <ppapi/cpp/rect.h>
+#include <ppapi/c/pp_errors.h>
+#include <ppapi/gles2/gl2ext_ppapi.h>
+
+pp::Instance* gNaclPPInstance;
+static int gNaclVideoWidth;
+static int gNaclVideoHeight;
+
+static int kNaClFlushDelayMs = 20;
+
+#include "SDL_nacl.h"
+
+extern "C" {
+
+#ifdef SDL_VIDEO_OPENGL_REGAL
+#include "SDL_opengl.h"
+#endif
+#include "SDL_video.h"
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../events/SDL_events_c.h"
+
+#define NACLVID_DRIVER_NAME "nacl"
+
+void SDL_NACL_SetInstance(PP_Instance instance, int width, int height) {
+  bool is_resize = gNaclPPInstance &&
+    (width != gNaclVideoWidth || height != gNaclVideoHeight);
+  if (!gNaclPPInstance) {
+    gNaclPPInstance = pp::Module::Get()->InstanceForPPInstance(instance);
+  }
+  gNaclVideoWidth = width;
+  gNaclVideoHeight = height;
+  if (is_resize && current_video) {
+    current_video->hidden->ow = width;
+    current_video->hidden->oh = height;
+    SDL_PrivateResize(width, height);
+  }
+}
+
+static void flush(void* data, int32_t unused);
+
+/* Initialization/Query functions */
+static int NACL_VideoInit(_THIS, SDL_PixelFormat *vformat);
+static SDL_Rect **NACL_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
+static SDL_Surface *NACL_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags);
+static void NACL_VideoQuit(_THIS);
+static void NACL_UpdateRects(_THIS, int numrects, SDL_Rect *rects);
+
+#ifdef SDL_VIDEO_OPENGL_REGAL
+static int NACL_GL_GetAttribute(_THIS, SDL_GLattr attrib, int* value);
+static int NACL_GL_MakeCurrent(_THIS);
+static void NACL_GL_SwapBuffers(_THIS);
+#endif
+
+/* The implementation dependent data for the window manager cursor */
+struct WMcursor {
+  // Fake cursor data to fool SDL into not using its broken (as it seems) software cursor emulation.
+};
+
+static void NACL_FreeWMCursor(_THIS, WMcursor *cursor);
+static WMcursor *NACL_CreateWMCursor(_THIS,
+                Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y);
+static int NACL_ShowWMCursor(_THIS, WMcursor *cursor);
+static void NACL_WarpWMCursor(_THIS, Uint16 x, Uint16 y);
+
+
+static int NACL_Available(void) {
+  return gNaclPPInstance != 0;
+}
+
+static void NACL_DeleteDevice(SDL_VideoDevice *device) {
+  SDL_free(device->hidden);
+  SDL_free(device);
+}
+
+static SDL_VideoDevice *NACL_CreateDevice(int devindex) {
+  SDL_VideoDevice *device;
+
+  assert(gNaclPPInstance);
+
+  /* Initialize all variables that we clean on shutdown */
+  device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+  if (device) {
+    SDL_memset(device, 0, (sizeof *device));
+    device->hidden = (struct SDL_PrivateVideoData *)
+        SDL_malloc((sizeof *device->hidden));
+  }
+  if (device == NULL || device->hidden == NULL) {
+    SDL_OutOfMemory();
+    if (device) {
+      SDL_free(device);
+    }
+    return 0;
+  }
+  SDL_memset(device->hidden, 0, (sizeof *device->hidden));
+
+  device->hidden->ow = gNaclVideoWidth;
+  device->hidden->oh = gNaclVideoHeight;
+
+  // TODO: query the fullscreen size
+
+  /* Set the function pointers */
+  device->VideoInit = NACL_VideoInit;
+  device->ListModes = NACL_ListModes;
+  device->SetVideoMode = NACL_SetVideoMode;
+  device->UpdateRects = NACL_UpdateRects;
+  device->VideoQuit = NACL_VideoQuit;
+  device->InitOSKeymap = NACL_InitOSKeymap;
+  device->PumpEvents = NACL_PumpEvents;
+
+  device->FreeWMCursor = NACL_FreeWMCursor;
+  device->CreateWMCursor = NACL_CreateWMCursor;
+  device->ShowWMCursor = NACL_ShowWMCursor;
+  device->WarpWMCursor = NACL_WarpWMCursor;
+
+#ifdef SDL_VIDEO_OPENGL_REGAL
+  device->GL_GetAttribute = NACL_GL_GetAttribute;
+  device->GL_MakeCurrent = NACL_GL_MakeCurrent;
+  device->GL_SwapBuffers = NACL_GL_SwapBuffers;
+#endif
+
+  device->free = NACL_DeleteDevice;
+
+  return device;
+}
+
+VideoBootStrap NACL_bootstrap = {
+  NACLVID_DRIVER_NAME, "SDL Native Client video driver",
+  NACL_Available, NACL_CreateDevice
+};
+
+
+int NACL_VideoInit(_THIS, SDL_PixelFormat *vformat) {
+  fprintf(stderr, "SDL: Congratulations you are using the SDL nacl video driver!\n");
+
+  /* Determine the screen depth (use default 8-bit depth) */
+  /* we change this during the SDL_SetVideoMode implementation... */
+  vformat->BitsPerPixel = 32;
+  vformat->BytesPerPixel = 4;
+
+  _this->info.current_w = gNaclVideoWidth;
+  _this->info.current_h = gNaclVideoHeight;
+
+  /* We're done! */
+  return 0;
+}
+
+SDL_Rect **NACL_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags) {
+  // TODO: list modes
+  return (SDL_Rect **) -1;
+}
+
+
+SDL_Surface *NACL_SetVideoMode(_THIS, SDL_Surface *current,
+    int width, int height, int bpp, Uint32 flags) {
+
+  fprintf(stderr, "SDL: setvideomode %dx%d bpp=%d opengl=%d flags=%u\n",
+          width, height, bpp, flags & SDL_OPENGL ? 1 : 0, flags);
+  fflush(stderr);
+
+  if (width > _this->hidden->ow || height > _this->hidden->oh)
+    return NULL;
+  _this->hidden->bpp = bpp = 32; // Let SDL handle pixel format conversion.
+  _this->hidden->w = width;
+  _this->hidden->h = height;
+
+  if (_this->hidden->context2d) {
+    delete _this->hidden->context2d;
+    _this->hidden->context2d = NULL;
+  }
+
+  if (_this->hidden->context3d) {
+    delete _this->hidden->context3d;
+    _this->hidden->context3d = NULL;
+  }
+
+  if (flags & SDL_OPENGL) {
+    int32_t attribs[] = {
+      PP_GRAPHICS3DATTRIB_ALPHA_SIZE, 8,
+      PP_GRAPHICS3DATTRIB_DEPTH_SIZE, 24,
+      PP_GRAPHICS3DATTRIB_STENCIL_SIZE, 8,
+      PP_GRAPHICS3DATTRIB_SAMPLES, 0,
+      PP_GRAPHICS3DATTRIB_SAMPLE_BUFFERS, 0,
+      PP_GRAPHICS3DATTRIB_WIDTH, width,
+      PP_GRAPHICS3DATTRIB_HEIGHT, height,
+      PP_GRAPHICS3DATTRIB_NONE
+    };
+    _this->hidden->context3d = new pp::Graphics3D(gNaclPPInstance,
+                                                  pp::Graphics3D(),
+                                                  attribs);
+    if (!gNaclPPInstance->BindGraphics(*_this->hidden->context3d)) {
+      fprintf(stderr, "***** Couldn't bind the graphic3d context *****\n");
+      return NULL;
+    }
+  } else {
+    _this->hidden->context2d =
+      new pp::Graphics2D(gNaclPPInstance, pp::Size(width, height), false);
+    assert(_this->hidden->context2d != NULL);
+
+    if (!gNaclPPInstance->BindGraphics(*_this->hidden->context2d)) {
+      fprintf(stderr, "***** Couldn't bind the graphic2d context *****\n");
+      return NULL;
+    }
+
+    if (_this->hidden->image_data)
+      delete _this->hidden->image_data;
+
+    _this->hidden->image_data = new pp::ImageData(gNaclPPInstance,
+      PP_IMAGEDATAFORMAT_BGRA_PREMUL,
+      _this->hidden->context2d->size(),
+      false);
+    assert(_this->hidden->image_data != NULL);
+
+    current->pixels = _this->hidden->image_data->data();
+  }
+
+  /* Allocate the new pixel format for the screen */
+  if (!SDL_ReallocFormat(current, bpp, 0xFF0000, 0xFF00, 0xFF, 0)) {
+    SDL_SetError("Couldn't allocate new pixel format for requested mode");
+    return NULL;
+  }
+
+  /* Set up the new mode framebuffer */
+  current->flags = flags & (SDL_FULLSCREEN | SDL_OPENGL);
+  _this->hidden->bpp = bpp;
+  _this->hidden->w = current->w = width;
+  _this->hidden->h = current->h = height;
+  current->pitch = current->w * (bpp / 8);
+
+  /* We're done */
+  return current;
+}
+
+static void NACL_UpdateRects(_THIS, int numrects, SDL_Rect *rects) {
+  if (_this->hidden->context2d == NULL) // not initialized
+    return;
+
+  assert(_this->hidden->image_data);
+  assert(_this->hidden->w > 0);
+  assert(_this->hidden->h > 0);
+
+  // Clear alpha channel in the ImageData.
+  unsigned char* start = (unsigned char*)_this->hidden->image_data->data();
+  unsigned char* end = start + (_this->hidden->w * _this->hidden->h * _this->hidden->bpp / 8);
+  for (unsigned char* p = start + 3; p < end; p +=4)
+    *p = 0xFF;
+
+  // Flush on the main thread.
+  for (int i = 0; i < numrects; ++i) {
+    SDL_Rect& r = rects[i];
+    _this->hidden->context2d->PaintImageData(*_this->hidden->image_data, pp::Point(), pp::Rect(r.x, r.y, r.w, r.h));
+  }
+
+  _this->hidden->context2d->Flush(pp::BlockUntilComplete());
+}
+
+static void NACL_FreeWMCursor(_THIS, WMcursor *cursor) {
+  delete cursor;
+}
+
+static WMcursor *NACL_CreateWMCursor(_THIS,
+    Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y) {
+  return new WMcursor();
+}
+
+static int NACL_ShowWMCursor(_THIS, WMcursor *cursor) {
+  return 1; // Success!
+}
+
+static void NACL_WarpWMCursor(_THIS, Uint16 x, Uint16 y) {
+}
+
+/* Note:  If we are terminated, this could be called in the middle of
+   another SDL video routine -- notably UpdateRects.
+*/
+void NACL_VideoQuit(_THIS) {
+  // No need to free pixels as this is a pointer directly to
+  // the pixel data within the image_data.
+  _this->screen->pixels = NULL;
+
+  delete _this->hidden->context2d;
+  delete _this->hidden->context3d;
+  delete _this->hidden->image_data;
+}
+
+#ifdef SDL_VIDEO_OPENGL_REGAL
+static void regalLogCallback(GLenum stream, GLsizei length, const GLchar *message, GLvoid *context) {
+  fprintf(stderr, "regal: %s\n", message);
+}
+
+static int NACL_GL_GetAttribute(_THIS, SDL_GLattr attrib, int* value)
+{
+  int unsupported = 0;
+  int nacl_attrib = 0;
+
+  switch (attrib) {
+    case SDL_GL_RED_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_RED_SIZE;
+      break;
+    case SDL_GL_GREEN_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_GREEN_SIZE;
+      break;
+    case SDL_GL_BLUE_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_BLUE_SIZE;
+      break;
+    case SDL_GL_ALPHA_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_ALPHA_SIZE;
+      break;
+    case SDL_GL_DEPTH_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_DEPTH_SIZE;
+      break;
+    case SDL_GL_STENCIL_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_STENCIL_SIZE;
+      break;
+    case SDL_GL_MULTISAMPLEBUFFERS:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_SAMPLE_BUFFERS;
+      break;
+    case SDL_GL_MULTISAMPLESAMPLES:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_SAMPLES;
+      break;
+    // The rest of the these attributes are not part of PPAPI
+    case SDL_GL_DOUBLEBUFFER:
+    case SDL_GL_BUFFER_SIZE:
+    case SDL_GL_ACCUM_RED_SIZE:
+    case SDL_GL_ACCUM_GREEN_SIZE:
+    case SDL_GL_ACCUM_BLUE_SIZE:
+    case SDL_GL_ACCUM_ALPHA_SIZE:
+    case SDL_GL_STEREO:
+    case SDL_GL_ACCELERATED_VISUAL:
+    case SDL_GL_SWAP_CONTROL:
+    default:
+      unsupported = 1;
+      break;
+  }
+
+  if (unsupported) {
+    SDL_SetError("OpenGL attribute is unsupported by NaCl: %d", attrib);
+    return -1;
+  }
+
+  int32_t attribs[] = {
+    nacl_attrib, 0,
+    PP_GRAPHICS3DATTRIB_NONE,
+  };
+
+  int retval = _this->hidden->context3d->GetAttribs(attribs);
+  if (retval != PP_OK) {
+    // TODO(sbc): GetAttribs seems to always return PP_ERROR_FAILED(-2).
+    //fprintf(stderr, "SDL: GetAttribs failed %#x -> %d\n", nacl_attrib, retval);
+    SDL_SetError("Error getting OpenGL attribute (%d) from NaCl: %d",
+                 attrib, retval);
+    return -1;
+  }
+
+  *value = attribs[1];
+  return 0;
+}
+
+static int NACL_GL_MakeCurrent(_THIS)
+{
+  if (!_this->hidden->context3d)
+  {
+    assert(_this->hidden->context3d);
+    SDL_SetError("GL_MakeCurrent called without an OpenGL video mode set");
+    return -1;
+  }
+  fprintf(stderr, "SDL: making GL context current\n");
+  int32_t pp_resource = _this->hidden->context3d->pp_resource();
+  glSetCurrentContextPPAPI(pp_resource);
+  pp::Module* module = pp::Module::Get();
+  const void* interface = module->GetBrowserInterface(PPB_OPENGLES2_INTERFACE);
+
+  RegalMakeCurrent(pp_resource, (struct PPB_OpenGLES2*)interface);
+  glLogMessageCallbackREGAL(regalLogCallback);
+  return 0;
+}
+
+static void NACL_GL_SwapBuffers(_THIS)
+{
+  if (!_this->hidden->context3d)
+  {
+    assert(_this->hidden->context3d);
+    fprintf(stderr, "SDL: GL_SwapBuffers called without an OpenGL video mode set\n");
+    return;
+  }
+  _this->hidden->context3d->SwapBuffers(pp::BlockUntilComplete());
+}
+#endif
+
+} // extern "C"
diff --git a/src/video/nacl/SDL_naclvideo.h b/src/video/nacl/SDL_naclvideo.h
new file mode 100644
index 0000000..a9fb7b5
--- /dev/null
+++ b/src/video/nacl/SDL_naclvideo.h
@@ -0,0 +1,36 @@
+#include "SDL_config.h"
+
+#ifndef _SDL_naclvideo_h
+#define _SDL_naclvideo_h
+
+extern "C" {
+#include "../SDL_sysvideo.h"
+#include "SDL_mutex.h"
+}
+
+#include <ppapi/cpp/instance.h>
+#include <ppapi/cpp/graphics_2d.h>
+#include <ppapi/cpp/graphics_3d.h>
+#include <vector>
+
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_VideoDevice *_this
+
+
+/* Private display data */
+
+struct SDL_PrivateVideoData {
+  int bpp;
+  int w, h;
+  void *buffer;
+
+  int ow, oh; // plugin output dimensions
+  int fsw, fsh; // fullscreen dimensions
+
+  pp::ImageData* image_data;
+  pp::Graphics2D* context2d;  // The PPAPI 2D drawing context.
+  pp::Graphics3D* context3d;  // The PPAPI 3D drawing context.
+};
+
+#endif /* _SDL_naclvideo_h */
diff --git a/src/video/nacl/eventqueue.h b/src/video/nacl/eventqueue.h
new file mode 100644
index 0000000..0a6a0cd
--- /dev/null
+++ b/src/video/nacl/eventqueue.h
@@ -0,0 +1,40 @@
+#ifndef _SDL_nacl_eventqueue_h
+#define _SDL_nacl_eventqueue_h
+
+#include "SDL_mutex.h"
+
+#include <queue>
+
+class EventQueue {
+public:
+  EventQueue() {
+    mu_ = SDL_CreateMutex();
+  }
+
+  ~EventQueue() {
+    SDL_DestroyMutex(mu_);
+  }
+
+  SDL_Event* PopEvent() {
+    SDL_LockMutex(mu_);
+    SDL_Event* event = NULL;
+    if (!queue_.empty()) {
+      event = queue_.front();
+      queue_.pop();
+    }
+    SDL_UnlockMutex(mu_);
+    return event;
+  }
+
+   void PushEvent(SDL_Event* event) {
+    SDL_LockMutex(mu_);
+    queue_.push(event);
+    SDL_UnlockMutex(mu_);
+   } 
+
+private:
+  std::queue<SDL_Event*> queue_;
+  SDL_mutex* mu_;
+};
+
+#endif // _SDL_nacl_eventqueue_h
diff --git a/test/configure.in b/test/configure.in
index 7c25c17..f24fb44 100644
--- a/test/configure.in
+++ b/test/configure.in
@@ -50,6 +50,18 @@ case "$host" in
             SYS_GL_LIBS="-lOSMesa"
         fi
 		;;
+    *-*-nacl*)
+        case "$CC" in
+            *pnacl*)
+                EXE=".pexe"
+                ;;
+            *)
+                EXE=".nexe"
+                ;;
+        esac
+        MATHLIB="-lm"
+        SYS_GL_LIBS=""
+        ;;
     *)
         EXE=""
         MATHLIB="-lm"
@@ -68,6 +80,12 @@ AM_PATH_SDL($SDL_VERSION,
 CFLAGS="$CFLAGS $SDL_CFLAGS"
 LIBS="$LIBS $SDL_LIBS"
 
+case "$host" in
+    *-*-nacl*)
+        LIBS="$LIBS -lnacl_io -l${NACL_CPP_LIB}"
+        ;;
+esac
+
 dnl Check for X11 path, needed for OpenGL on some systems
 AC_PATH_X
 if test x$have_x = xyes; then
